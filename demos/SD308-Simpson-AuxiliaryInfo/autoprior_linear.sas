data var_transformed;
    set &variables;
    if transform = 'log' then trans_variable = cat("log_", variable);
    else if transform = 'std' then trans_variable = cat("std_", variable);
    else if transform = 'none' then trans_variable = variable;
run;

data _null_;
    eof = 0;
    length logvars varchar(*);
    length loggedvars varchar(*);
    length stdvars varchar(*);
    length stdedvars varchar(*);
    length classvars varchar(*);
    length nonevars varchar(*);
    length covariates varchar(*);
    length num_covariates varchar(*);
    do i=1 by 1 until (eof);
        set var_transformed end=eof;
        if transform = 'log' then do;
            logvars = catx(" ", logvars, trim(variable));
            loggedvars = catx(" ", loggedvars, trim(trans_variable));
            end;
        else if transform = 'std' then do;
            stdvars = catx(" ", stdvars, trim(variable));
            stdedvars = catx(" ", stdedvars, trim(trans_variable));
            end;
        else do;
            if type = 'class' then classvars = catx(" ", classvars, trim(trans_variable));
            else nonevars = catx(" ", nonevars, trim(trans_variable));
            end;
        if response then do;
            call symputx('response', trim(trans_variable));
            if transform = 'log' then call symputx('loglog', 1);
            else call symputx('loglog', 0);
            end;
        else do;
            covariates = catx(" ", covariates, trim(trans_variable));
            if type ~= 'class' then num_covariates = catx(" ", num_covariates, trim(trans_variable));
            end;
        if eof then do;
            call symputx('logvars', logvars);
            call symputx('loggedvars', loggedvars);
            call symputx('stdvars', stdvars);
            call symputx('stdedvars', stdedvars);
            call symputx('classvars', classvars);
            call symputx('nonevars', nonevars);
            call symputx('covariates', covariates);
            call symputx('num_covariates', num_covariates);
            end;
        end;
run;

data data_log;
    set &dataset;
    array logged_ &loggedvars;
    array log_ &logvars;
    array stded_ &stdedvars;
    array std_ &stdvars;
    do over log_;
        logged_ = log(log_);
        end;
    do over std_;
        stded_ = std_;
        end;
    keep &loggedvars &stdedvars &nonevars &classvars;
run;

proc standard data = data_log mean=0 std=1 out=data_transformed;
    var &stdedvars;
run;

proc summary data = data_transformed;
    var &loggedvars &stdedvars &nonevars;
    output out = transformed_summary;
run;

proc summary data = data_transformed;
    class &classvars;
    types &classvars;
    output out = class_summary;
run;

%let classvars_str="%sysfunc(tranwrd(%cmpres(&classvars),%str( ),%str( )))";

data class_parameters;
    set class_summary;
    array classvars_ &classvars;
    N = dim(classvars_);
    do i = 1 to N;
        if _type_ = i then do;
            idx = dim(classvars_) - i + 1;
            classvar_type = scan(&classvars_str, idx, ' ');
            parameter = cat(strip(classvar_type), "_", strip(classvars_[idx]));
            end;
        end;
    type = 'class';
    transform = 'none';
    keep &classvars _TYPE_ parameter type transform;
run;


data _null_;
    eof = 0;
    do i = 1 by 1 until (eof);
        set transformed_summary end=eof;
        if _STAT_ = 'STD' then call symputx('response_std', &response);
        end;
run;

proc transpose data = transformed_summary out = transposed_summary;
    id _stat_;
    var &num_covariates;
run;

data covariates_transformed;
    merge var_transformed(where=(response = 0 and type = 'numeric'))
        transposed_summary(rename = (_name_ = trans_variable));
run;

data prior;
    eof = 0;
    set covariates_transformed end = eof;
    parameter = trans_variable;
    distribution = 'normal';
    hyper1 = 0;
    if transform = 'log' then do;
        if &loglog then sd = &log_s;
        else sd = &none_s * &response_std / std;
        end;
    else if transform = 'std' then sd = &std_s * &response_std;
    else sd = &none_s * &response_std / std;
    hyper2 = sd * sd;
    retain max_sd 0;
    if sd > max_sd then max_sd = sd;
    min = .;
    max = .;
    output;
    if eof then do;
        eof = 0;
        do i = 1 by 1 until(eof);
            set class_parameters end = eof;
            distribution = 'normal';
            hyper1 = 0;
            sd = &class_s * &response_std;
            hyper2 = sd * sd;
            if sd > max_sd then max_sd = sd;
            min = .;
            max = .;
            output;
            end;
        parameter = 'intercept';
        distribution = 'normal';
        hyper1 = &intercept_mean;
        sd =  max_sd * &intercept_s;
        hyper2 = sd * sd;
        min = .;
        max = .;
        output;
        parameter = '_sigma';
        distribution = 'normal';
        hyper1 = &sigma_mean;
        sd = &response_std * &sigma_s;
        hyper2 = sd * sd;
        min = .;
        max = .;
	output;
        end;
    keep parameter distribution hyper1 hyper2 min max;
run;

data prior;
    format parameter distribution hyper1 hyper2 min max;
    set prior;
run;

%let prior = prior;

%let model = class &classvars %nrquote(;) model &response = &covariates %nrquote(;);
